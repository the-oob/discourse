def process_popmail(popmail)
  begin
    mail_string = popmail.pop
    Email::Receiver.new(mail_string).process
  rescue
    putc "!"
  else
    putc "."
  end
end

POLL_MAILBOX_ERRORS_KEY ||= "poll_mailbox_errors".freeze

def mark_as_errored!
	now = Time.now.to_i
	$redis.zadd(POLL_MAILBOX_ERRORS_KEY, now, now.to_s)
end

def handle_failure(mail_string, e)
      log_email_process_failure(mail_string, e)

      message_template = case e
        when Email::Receiver::EmptyEmailError             then :email_reject_empty
        when Email::Receiver::NoBodyDetectedError         then :email_reject_empty
        when Email::Receiver::UserNotFoundError           then :email_reject_user_not_found
        when Email::Receiver::ScreenedEmailError          then :email_reject_screened_email
        when Email::Receiver::AutoGeneratedEmailError     then :email_reject_auto_generated
        when Email::Receiver::InactiveUserError           then :email_reject_inactive_user
        when Email::Receiver::BlockedUserError            then :email_reject_blocked_user
        when Email::Receiver::BadDestinationAddress       then :email_reject_bad_destination_address
        when Email::Receiver::StrangersNotAllowedError    then :email_reject_strangers_not_allowed
        when Email::Receiver::InsufficientTrustLevelError then :email_reject_insufficient_trust_level
        when Email::Receiver::ReplyUserNotMatchingError   then :email_reject_reply_user_not_matching
        when Email::Receiver::TopicNotFoundError          then :email_reject_topic_not_found
        when Email::Receiver::TopicClosedError            then :email_reject_topic_closed
        when Email::Receiver::InvalidPost                 then :email_reject_invalid_post
        when ActiveRecord::Rollback                       then :email_reject_invalid_post
        when Email::Receiver::InvalidPostAction           then :email_reject_invalid_post_action
        when Discourse::InvalidAccess                     then :email_reject_invalid_access
        when RateLimiter::LimitExceeded                   then :email_reject_rate_limit_specified
      end

      template_args = {}
      client_message = nil

      # there might be more information available in the exception
      if message_template == :email_reject_invalid_post && e.message.size > 6
        message_template = :email_reject_invalid_post_specified
        template_args[:post_error] = e.message
      end

      if message_template == :email_reject_rate_limit_specified
        template_args[:rate_limit_description] = e.description
      end

      if message_template == :email_reject_auto_generated
        template_args[:mark_as_reply_to_auto_generated] = true
      end

      if message_template
        # inform the user about the rejection
        message = Mail::Message.new(mail_string)
        template_args[:former_title] = message.subject
        template_args[:destination] = message.to
        template_args[:site_name] = SiteSetting.title

        client_message = RejectionMailer.send_rejection(message_template, message.from, template_args)
        Email::Sender.new(client_message, message_template).send
      else
        mark_as_errored!
        log_email_process_failure(mail_string, e)
      end

      client_message
end

def log_email_process_failure(mail_string, exception)
      if SiteSetting.log_mail_processing_failures
        Rails.logger.warn("Email can not be processed: #{exception}\n\n#{mail_string}")
      end
end

def set_incoming_email_rejection_message(incoming_email, message)
	incoming_email.update_attributes!(rejection_message: message)
end


desc "import a single email from stdin"
task "emails:read" => :environment do
begin
	mail_string = STDIN.read
	receiver = Email::Receiver.new(mail_string)
	receiver.process!
rescue Email::Receiver::BouncedEmailError => e
        log_email_process_failure(mail_string, e)

        set_incoming_email_rejection_message(
          receiver.incoming_email,
          I18n.t("emails.incoming.errors.bounced_email_error")
        )
rescue Email::Receiver::AutoGeneratedEmailReplyError => e
        log_email_process_failure(mail_string, e)

        set_incoming_email_rejection_message(
          receiver.incoming_email,
          I18n.t("emails.incoming.errors.auto_generated_email_reply")
        )
rescue => e
        rejection_message = handle_failure(mail_string, e)
        if rejection_message.present? && receiver && (incoming_email = receiver.incoming_email)
          set_incoming_email_rejection_message(incoming_email, rejection_message.body.to_s)
	end
end
end

desc "use this task to import a mailbox into Disourse"
task "emails:import" => :environment do
  begin
    unless SiteSetting.email_in
      puts "ERROR: you should enable the 'email_in' site setting before running this task"
      exit(1)
    end

    address  = ENV["ADDRESS"].presence || "pop.gmail.com"
    port     = (ENV["PORT"].presence || 995).to_i
    ssl      = (ENV["SSL"].presence || "1") == "1"
    username = ENV["USERNAME"].presence
    password = ENV["PASSWORD"].presence

    if username.blank?
      puts "ERROR: expecting USERNAME=<username> rake emails:import"
      exit(2)
    elsif password.blank?
      puts "ERROR: expecting PASSWORD=<password> rake emails:import"
      exit(3)
    end

    RateLimiter.disable

    mails_left = 1
    pop3 = Net::POP3.new(address, port)
    pop3.enable_ssl if ssl

    while mails_left > 0
      pop3.start(username, password) do |pop|
        pop.delete_all do |p|
          process_popmail(p)
        end
        mails_left = pop.n_mails
      end
    end

    puts "Done"
  rescue Net::POPAuthenticationError
    puts "AUTH EXCEPTION: please make sure your credentials are correct."
    exit(10)
  ensure
    RateLimiter.enable
  end
end
